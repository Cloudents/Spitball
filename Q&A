pragma solidity ^0.4.20;
import "browser/SafeMath.sol";
import "browser/ERC20.sol";

contract QAndA {
    
    
    struct QuestionData  
    {
    
    uint256 price;
    address qOwner;
    address qWiner;
    uint256 answerCounter;
    mapping (string => AnswersData) answers;
    mapping (uint => string) answersIndex; 
    }
    
    struct AnswersData
    {
    string aid;
    address[] upVoteAddr;
    }
    
    mapping (uint256 => QuestionData) id;
    SpitballToken public tokenReward;
    mapping (address => uint256) public balanceOf;
    
     
    event AnswerAccepted(address indexed from, address indexed to, uint256 value);
    event NewAnswer (string answerId);
    //event FundTransfer(address backer, uint256 amount, bool isContribution);
    
    function QAndA (address _addressOfTokenUsedAsReward) public {
        tokenReward = SpitballToken(_addressOfTokenUsedAsReward);
      
    }


    function destroy(uint256 _qId) internal
    {  
        for(uint i=0;i<id[_qId].answerCounter;i++)
        {
            for(uint j=0; j < id[_qId].answers[id[_qId].answersIndex[i]].upVoteAddr.length; j++)
            {
                delete(id[_qId].answers[id[_qId].answersIndex[i]].upVoteAddr[j]);
            }
            delete(id[_qId].answers[id[_qId].answersIndex[i]]);
        }
            delete(id[_qId]);
    }

    
    function submitNewQuestion (uint256 _qId, uint256 _price)  public
    {
        QuestionData memory data = QuestionData(_price, msg.sender, address(0), 0);
        id[_qId] = data;
        tokenReward.approve(msg.sender, SafeMath.mul(_price, 10**18));
        tokenReward.transferFrom(msg.sender, address(this), SafeMath.mul(_price, 10**18));
        balanceOf[msg.sender] = SafeMath.add(balanceOf[msg.sender], SafeMath.mul(_price, 10**18));
    }
    
    function submitNewAnswer (uint256 _qId, string _answerId) public //returns (uint256)
    {   //see if can be private and call from upvote function
        require(id[_qId].price > 0);
        address[] memory tempUpVote = new address[](0);
        AnswersData memory data = AnswersData(_answerId, tempUpVote);
        id[_qId].answers[_answerId] = data;
        id[_qId].answerCounter = SafeMath.add(1, id[_qId].answerCounter);
        NewAnswer(_answerId);
    }
    
    
    function approveAnswer (uint256 _qId, string _answerId, address _winner) public 
    {
        id[_qId].qWiner = _winner;
        tokenReward.transfer(_winner, SafeMath.mul(id[_qId].price, 10**18));
        balanceOf[msg.sender] = SafeMath.sub(balanceOf[msg.sender], SafeMath.mul(id[_qId].price, 10**18));
        
        if(id[_qId].answers[_answerId].upVoteAddr.length > 0)
        {
             for(uint256 i=0; i<id[_qId].answers[_answerId].upVoteAddr.length; i++){
                 
                 tokenReward.transfer(id[_qId].answers[_answerId].upVoteAddr[i], SafeMath.mul(1, 10**18));
                 balanceOf[msg.sender] = SafeMath.sub(balanceOf[id[_qId].answers[_answerId].upVoteAddr[i]], SafeMath.mul(id[_qId].price, 10**18));
             }
        }
      // Spred founds to upvoters
        destroy(_qId); // nedd to see if working
    }
    
    function returnFoundsToUser (uint256 _qId) public {
        tokenReward.transfer(msg.sender, SafeMath.mul(id[_qId].price, 10**18));
        balanceOf[msg.sender] = SafeMath.sub(balanceOf[msg.sender], SafeMath.mul(id[_qId].price, 10**18));
        destroy(_qId); // nedd to see if working
    }
    
    function spreadFounds (uint256 _qId, uint8 percentage) public {
        tokenReward.transfer(msg.sender, SafeMath.mul(SafeMath.mul(id[_qId].price, SafeMath.div(percentage,100)), 10**18));
    }
    
    function upVote (uint256 _qId, string _answerId, uint256 _value) public 
    {
    
    require(keccak256(id[_qId].answers[_answerId].aid) == keccak256(_answerId));
        
    id[_qId].answers[_answerId].upVoteAddr.push(msg.sender);

    tokenReward.approve(msg.sender, SafeMath.mul(_value, 10**18));
    tokenReward.transferFrom(msg.sender, address(this), SafeMath.mul(_value, 10**18));
    balanceOf[msg.sender] = SafeMath.add(balanceOf[msg.sender], SafeMath.mul(_value, 10**18));
    }
    
    
    function returnUpVoteList (uint256 _qId, string _answerId) public view returns (bytes32[] memory a){
        bytes32[] memory addresses = new bytes32[](id[_qId].answers[_answerId].upVoteAddr.length);
          for(uint256 i=0; i<id[_qId].answers[_answerId].upVoteAddr.length; i++){
            addresses[i] = bytes32(id[_qId].answers[_answerId].upVoteAddr[i]);
        }
        return addresses;
    }
    
    

}
